//
//  ViewController.swift
//  Wine Ring
//
//  Created by Nicholas Bortolussi on 10/4/16.
//  Copyright Â© 2017 RingIT, Inc. All rights reserved.
//
import UIKit

import AVFoundation
import CoreData
import Photos
import Kingfisher
import SwiftEventBus
import SideMenu

public class ImageRecController: BaseController, UIImagePickerControllerDelegate, UINavigationControllerDelegate, ConfirmationDelegate, AVCapturePhotoCaptureDelegate, ImageEditMatchDelegate, WineMatchDelegate, WinePagerDelegate {
    
    @IBOutlet weak var captureView: UIView!
    @IBOutlet weak var greenOutline: UIImageView!
    @IBOutlet weak var gallery: UIImageView!
    @IBOutlet weak var flashButton: UIButton!
    @IBOutlet weak var multiButton: UIButton!
    @IBOutlet weak var doneButton: WRButton!
    @IBOutlet weak var captureButton: UIButton!

    let dispatchGroup = DispatchGroup()
    var previewLayer : AVCaptureVideoPreviewLayer?
    var shouldSaveToCameraRoll = false
    var collectionGroup : CollectionGroup?
    var multiMode = false
    var images : [UIImage]?
    var imageMatches : [UIImage : NSManagedObjectID]?
    var imageMatchesWines : [UIImage : Wine]?
    var imageRecIds : [UIImage : [NSManagedObjectID]]?
    var imageInfo : [UIImage : [String : Any?]]?
    public var browse = false
    public var openMenu = false
    var displayWines = Array<Array<Wine>>()
    
    public override func viewDidLoad() {
        super.viewDidLoad()
        
        NotificationCenter.default.addObserver(self, selector: #selector(contextDidSave(_:)), name: Notification.Name.NSManagedObjectContextDidSave, object: nil)
        
        if (openMenu) {
            menuClicked()
        } else {
            handleStatus(status: AVCaptureDevice.authorizationStatus(for: AVMediaType.video))
            handleStatusForLibrary(status: PHPhotoLibrary.authorizationStatus())
        }
    }
    
    public override func sideMenuWillDisappear(menu: SideMenuNavigationController, animated: Bool) {
        super.sideMenuWillDisappear(menu: menu, animated: animated)
        
        handleStatus(status: AVCaptureDevice.authorizationStatus(for: AVMediaType.video))
        handleStatusForLibrary(status: PHPhotoLibrary.authorizationStatus())
    }
    
    @objc func contextDidSave(_ notification: Notification) {
        DispatchQueue.main.async {
            NSManagedObjectContext.mr_default().mergeChanges(fromContextDidSave: notification)
        }
    }
    
    func showAllowCameraConfirmationDialog() {
        let confirmationController = UIStoryboard(name: "Reusable", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "Confirmation") as! ConfirmationController
        confirmationController.modalPresentationStyle = .overCurrentContext
        confirmationController.delegate = self
        confirmationController.identifier = "Allow"
        confirmationController.affirmativeText = WRTools.getString(string: "settings")
        confirmationController.text = WRTools.getString(string: "ios_camera_allow_fail")
        present(confirmationController, animated: true, completion: nil)
    }
    
    func showAllowPhotoAccessConfirmationDialog() {
        let confirmationController = UIStoryboard(name: "Reusable", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "Confirmation") as! ConfirmationController
        confirmationController.modalPresentationStyle = .overCurrentContext
        confirmationController.delegate = self
        confirmationController.identifier = "Allow"
        confirmationController.affirmativeText = WRTools.getString(string: "settings")
        confirmationController.text = WRTools.getString(string: "ios_photos_allow_fail")
        present(confirmationController, animated: true, completion: nil)
    }
    
    public override func clearMemory() {
        super.clearMemory()
        CameraTools.sharedInstance.closeCamera()
    }
    
    func handleStatus(status : AVAuthorizationStatus) {
        switch status {
        case.authorized:
            beginSession()
            break
        case.denied:
            showAllowCameraConfirmationDialog()
            break
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: AVMediaType.video, completionHandler: { (granted :Bool) -> Void in
                DispatchQueue.main.async {
                    if (granted) {
                        self.beginSession()
                    }
                }
            })
            break
        case .restricted:
            showAllowCameraConfirmationDialog()
            break
        }
    }
    
    func handleStatusForLibrary(status : PHAuthorizationStatus) {
        switch status {
        case.authorized:
            fetchMostRecentPhoto()
            break
        case.denied:
            showAllowPhotoAccessConfirmationDialog()
            break
<<<<<<< HEAD
        case.limited:
=======
        case .limited:
>>>>>>> hotfix
            showAllowPhotoAccessConfirmationDialog()
            break
        case .notDetermined:
            PHPhotoLibrary.requestAuthorization({ (status: PHAuthorizationStatus) in
                DispatchQueue.main.async {
                    self.handleStatusForLibrary(status: status)
                }
            })
            break
        case .restricted:
            showAllowPhotoAccessConfirmationDialog()
            break
        }
    }
    
    func beginSession() {
        WRTools.startNewWorkThread {
            if (CameraTools.sharedInstance.openCamera()) {
            self.previewLayer = AVCaptureVideoPreviewLayer(session: CameraTools.sharedInstance.getCaptureSession())
            self.previewLayer!.videoGravity = AVLayerVideoGravity.resizeAspectFill
            DispatchQueue.main.async {
                self.captureView.layer.addSublayer(self.previewLayer!)
                self.previewLayer!.frame.size = self.captureView.frame.size
                if (CameraTools.sharedInstance.getCaptureDevice() != nil) {
                    self.flashButton.isHidden = !CameraTools.sharedInstance.getCaptureDevice()!.hasTorch
                } else {
                    self.flashButton.isHidden = true
                }
            }
        }
        }
    }
    
    public override func viewDidLayoutSubviews() {
        previewLayer?.frame.size = captureView.frame.size
    }
    
    public override func setupLayout() {
        super.setupLayout()
        
        captureButton.setImage(WRTools.getImage(name: "ic_camera_trigger_colored.png"), for: .normal)
        flashButton.setImage(WRTools.getImage(name: "ic_flash_solid.png"), for: .normal)
        flashButton.setImage(WRTools.getImage(name: "ic_flash_filled.png"), for: .selected)
        multiButton.setImage(WRTools.getImage(name: "ic_camera_multi_colored.png"), for: .normal)
        greenOutline.image = WRTools.getImage(name: "label_frame.png")
        
        if (CameraTools.sharedInstance.getCaptureDevice() != nil) {
            flashButton.isHidden = !CameraTools.sharedInstance.getCaptureDevice()!.hasTorch
        }
        doneButton.setTitle(WRTools.getString(string: "done"), for: .normal, setSize: true)
        WRNavigationBar?.setAltImage(image: WRTools.getImage(name: "ic_keyboard_colored.png"), target: self, action: #selector(keyboardPressed))
        WRNavigationBar?.setLogoVisible()
        if (UserDefaults.init(suiteName: "WineRing")!.bool(forKey: "WineRingApp")) {
            setupSideMenu()
        } else {
            setupCloseableNavigationBar()
        }
        
        if (browse) {
            multiButton.isHidden = true
        }
    }
    
    @objc func keyboardPressed() {
        let viewController = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "KeyboardNav") as! UINavigationController
        let textSearchController = viewController.viewControllers.first as? TextSearchController
        textSearchController?.browse = browse
        textSearchController?.hideCantFind = browse
        WRTools.rootTransferTransition(viewController: viewController)
    }
    
    @IBAction func galleryClicked() {
        // open gallery
        if UIImagePickerController.isSourceTypeAvailable(UIImagePickerController.SourceType.photoLibrary){
            let imagePicker = UIImagePickerController()
            imagePicker.delegate = self
            imagePicker.sourceType = UIImagePickerController.SourceType.photoLibrary
            imagePicker.allowsEditing = false
            present(imagePicker, animated: true, completion: nil)
        }
    }
    
    public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        picker.dismiss(animated: true, completion: nil)
        if let image = info[.originalImage] as? UIImage {
            self.shouldSaveToCameraRoll = false
            self.pictureTaken()
            self.resizeAndOrient(image: image)
        }
    }
    
    func resizeAndOrient(image : UIImage) {
        showLoadingView()
        WRTools.startNewWorkThread {
            let newImage = WRTools.resizeImage(image: WRTools.fixOrientation(img: image), newDimension: 1000)!
            DispatchQueue.main.async {
                self.hideLoadingView()
                self.uploadImageAfterTake(image: newImage)
                self.showEditMatchController(image: newImage)
            }
        }
    }
    
    func fetchMostRecentPhoto() {
        let size = gallery.frame.size
        WRTools.startNewWorkThread {
            let imgManager = PHImageManager.default()
            let requestOptions = PHImageRequestOptions()
            requestOptions.isSynchronous = true
            
            let fetchOptions = PHFetchOptions()
            fetchOptions.sortDescriptors = [NSSortDescriptor(key:"creationDate", ascending: true)]
            
            let fetchResult = PHAsset.fetchAssets(with: PHAssetMediaType.image, options: fetchOptions)
            
            if fetchResult.count > 0 {
                imgManager.requestImage(for: fetchResult.object(at: fetchResult.count - 1) as PHAsset, targetSize: size, contentMode: PHImageContentMode.aspectFill, options: requestOptions, resultHandler: { (image, _) in
                    
                    DispatchQueue.main.async {
                        self.gallery.image = image
                    }
                })
            }
        }
    }
    
    @IBAction func takePictureClicked() {
        if (self.previewLayer != nil && self.previewLayer!.connection != nil) {
            let photoSettings = AVCapturePhotoSettings.init()
            self.previewLayer!.connection!.isEnabled = false
            CameraTools.sharedInstance.getStillImageOutput().capturePhoto(with: photoSettings, delegate: self)
        }
    }
    
    public func photoOutput(_ captureOutput: AVCapturePhotoOutput, didFinishProcessingPhoto photoSampleBuffer: CMSampleBuffer?, previewPhoto previewPhotoSampleBuffer: CMSampleBuffer?, resolvedSettings: AVCaptureResolvedPhotoSettings, bracketSettings: AVCaptureBracketedStillImageSettings?, error: Error?) {
        if let photoSampleBuffer = photoSampleBuffer {
            if let imageData = AVCapturePhotoOutput.jpegPhotoDataRepresentation(forJPEGSampleBuffer: photoSampleBuffer, previewPhotoSampleBuffer: previewPhotoSampleBuffer) {
                self.shouldSaveToCameraRoll = true
                self.pictureTaken()
                let image = self.prepareImageForDisplay(image: UIImage.init(data: imageData)!)!
                self.uploadImageAfterTake(image: image)
                self.showEditMatchController(image: image)
            }
        }
    }
    
    func showEditMatchController(image : UIImage) {
        if (!multiMode) {
            images?.removeAll()
        }
        let imageDisplay = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "ImageConfirmController") as! ImageConfirmController
        imageDisplay.imagePassed = image
        imageDisplay.multi = multiMode
        imageDisplay.browse = browse
        imageDisplay.delegate = self
        imageDisplay.showOptions = (images == nil || images!.count == 0) && UserDefaults.init(suiteName: "WineRing")!.bool(forKey: "isSKS")
        self.navigationController?.pushViewController(imageDisplay, animated: true)
    }
    
    func pictureTaken() {
        if (flashButton.isSelected) {
            do {
                try CameraTools.sharedInstance.getCaptureDevice()?.lockForConfiguration()
                CameraTools.sharedInstance.getCaptureDevice()?.torchMode = AVCaptureDevice.TorchMode.off
            } catch {
                print(error)
            }
            CameraTools.sharedInstance.getCaptureDevice()?.unlockForConfiguration()
        }
    }
    
    func prepareImageForDisplay(image : UIImage) -> UIImage? {
        let image = WRTools.resizeImage(image: image, newDimension: captureView.frame.height)!
        let differenceInWidths = image.size.width - captureView.frame.width
        let rect = CGRect.init(x: (differenceInWidths / 2) + greenOutline.frame.origin.x, y: greenOutline.frame.origin.y - WRNavigationBar!.frame.maxY, width: greenOutline.frame.width, height: greenOutline.frame.height)
        let imageRef = image.cgImage!.cropping(to: rect)
        let finalImage: UIImage = WRTools.resizeImage(image: UIImage(cgImage: imageRef!, scale: image.scale, orientation: image.imageOrientation), newDimension: 1000)!
        return finalImage
    }
    
    @IBAction func flashClicked() {
        if (CameraTools.sharedInstance.getCaptureDevice()?.isTorchAvailable ?? false) {
            do {
                try CameraTools.sharedInstance.getCaptureDevice()?.lockForConfiguration()
                if (flashButton.isSelected) {
                    CameraTools.sharedInstance.getCaptureDevice()?.torchMode = AVCaptureDevice.TorchMode.off
                    flashButton.isSelected = false
                } else {
                    try CameraTools.sharedInstance.getCaptureDevice()?.setTorchModeOn(level: 1.0)
                    flashButton.isSelected = true
                }
            } catch {
                print(error)
            }
            CameraTools.sharedInstance.getCaptureDevice()?.unlockForConfiguration()
        }
    }
    
    @IBAction func multiClicked() {
        images?.removeAll()
        multiMode = !multiMode
        if (multiMode) {
            WRTools.showSnackBar(message: WRTools.getString(string: "switched_multi"))
            multiButton.setImage(WRTools.getImage(name: "ic_camera_single_colored.png"), for: .normal)
        } else {
            WRTools.showSnackBar(message: WRTools.getString(string: "switched_single"))
            multiButton.setImage(WRTools.getImage(name: "ic_camera_multi_colored.png"), for: .normal)
        }
    }
    
    @IBAction func doneClicked() {
        let image = images![0]

        if (self.imageInfo == nil) {
            self.imageInfo = [image : ["go" : "go"]]
        } else if (self.imageInfo![image] == nil) {
            self.imageInfo![image] = ["go" : "go"]
        }
        
        resetView(turnTorchBackOn: false)
        let wineMatchController = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "ImageRecMatchPager") as! ImageRecMatchPager
        let viewController = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "ImageRecMatchController") as! ImageRecMatchController
        viewController.actualImage = image
        viewController.info = imageInfo?[image]
        viewController.recResults = imageRecIds?[image]
        viewController.multi = multiMode
        viewController.match = imageMatchesWines?[image]
        viewController.wineMatchProtocol = wineMatchController
        viewController.currentWineLocation = 1
        viewController.totalWines = images!.count
        wineMatchController.setViewControllers([viewController], direction: .forward, animated: true, completion: nil)
        wineMatchController.wineMatchDelegate = self
        navigationController?.pushViewController(wineMatchController, animated: true)
    }
    
    func infoEntered(image : UIImage, infoDictionary : [String : Any?]) {
        if (imageInfo == nil) {
            imageInfo = [image : infoDictionary]
        } else {
            imageInfo![image] = infoDictionary
        }
    }
    
    public func savePressed(image: UIImage, imageEdited : Bool, vintage: NSNumber) {
        if (self.images == nil) {
            self.images = [image]
        } else {
            self.images!.append(image)
        }
        if (shouldSaveToCameraRoll) {
            UIImageWriteToSavedPhotosAlbum(image, self, nil, nil)
        }
        
        let operation = BlockOperation()
        if (multiMode) {
            WRTools.showSnackBar(message: WRTools.getString(string: "photo_received"))
            resetView(turnTorchBackOn: true)
            multiButton.isHidden = true
            doneButton.isHidden = false
            
            operation.addExecutionBlock { () -> Void in
                do {
                    let context = NSManagedObjectContext.mr_()
                    context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
                    
                    if (operation.isCancelled) {
                        return
                    }
                    
                    let imageRecIds : [NSManagedObjectID]
                    if (imageEdited) {
                        // we need to upload the new image
                        let imageId = try self.uploadImage(context: context, image: image)
                        self.imageInfo![image] = ["imageId" : imageId]
                        imageRecIds = try self.getImageRecs(context: context, imageId: imageId)
                    } else if (self.imageRecIds != nil && self.imageRecIds![image] != nil) {
                        // our image was already uploaded
                        imageRecIds = self.imageRecIds![image]!
                    } else {
                        // we need to wait for the upload process to finish
                        self.dispatchGroup.wait()
                        if (self.imageRecIds == nil || self.imageRecIds![image] == nil) {
                            // failed initial upload
                            throw WRException.UnknownError
                        }
                        imageRecIds = self.imageRecIds![image]!
                    }
                    
                    if (operation.isCancelled) {
                        return
                    }
                    
                    if (self.imageRecIds == nil) {
                        self.imageRecIds = [image : imageRecIds]
                    } else {
                        self.imageRecIds![image] = imageRecIds
                    }
                } catch {
                    // nada
                }
            }
        } else {
            showLoadingView()
            operation.addExecutionBlock { () -> Void in
                do {
                    let context = NSManagedObjectContext.mr_()
                    context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
                    let imageRecIds : [NSManagedObjectID]
                    if (imageEdited) {
                        // we need to upload the new image
                        let imageId = try self.uploadImage(context: context, image: image)
                        self.imageInfo![image] = ["imageId" : imageId]
                        imageRecIds = try self.getImageRecs(context: context, imageId: imageId)
                    } else if (self.imageRecIds != nil && self.imageRecIds![image] != nil) {
                        // our image was already uploaded
                        imageRecIds = self.imageRecIds![image]!
                    } else {
                        // we need to wait for the upload process to finish
                        self.dispatchGroup.wait()
                        if (self.imageRecIds == nil || self.imageRecIds![image] == nil) {
                            // failed initial upload
                            throw WRException.UnknownError
                        }
                        imageRecIds = self.imageRecIds![image]!
                    }
                    
                    if (self.imageRecIds == nil) {
                        self.imageRecIds = [image : imageRecIds]
                    } else {
                        self.imageRecIds![image] = imageRecIds
                    }
                    
                    DispatchQueue.main.async {
                        self.hideLoadingView()
                        if (self.browse) {
                            // browsing
                            if (imageRecIds.count > 0) {
                                // matches found
                                let viewController = UIStoryboard(name: "Wine", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "WineList") as! WineListController
                                viewController.navigationTitle = WRTools.getString(string: "will_i_like_it")
                                viewController.originalWines = ImageRec.sortImageRecs(imageRecs: ImageRec.mr_findAll(with: NSPredicate(format: "self IN %@", imageRecIds)) as! [ImageRec]).map { $0.wine }
                                self.navigationController?.pushViewController(viewController, animated: true)
                                self.resetView(turnTorchBackOn: false)
                            } else {
                                // no matches found while browsing
                                self.noMatchFound(image: image)
                            }
                        } else {
                            // single capture success
                            self.doneClicked()
                        }
                    }
                } catch {
                    DispatchQueue.main.async {
                        self.hideLoadingView()
                        if (self.browse) {
                            // browsing
                            self.failedConnection(image: image)
                        } else {
                            self.doneClicked()
                        }
                    }
                }
            }
        }
        operationQueue.addOperation(operation)
    }
    
    func noMatchFound(image : UIImage) {
        let confirmationController = UIStoryboard(name: "Reusable", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "Confirmation") as! ConfirmationController
        confirmationController.modalPresentationStyle = .overCurrentContext
        confirmationController.delegate = self
        confirmationController.object = image
        confirmationController.identifier = "NoResults"
        confirmationController.affirmativeText = WRTools.getString(string: "okay")
        confirmationController.text = WRTools.getString(string: "select_vintage_sorry")
        self.present(confirmationController, animated: true, completion: nil)
    }
    
    func failedConnection(image : UIImage) {
        let confirmationController = UIStoryboard(name: "Reusable", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "Confirmation") as! ConfirmationController
        confirmationController.modalPresentationStyle = .overCurrentContext
        confirmationController.delegate = self
        confirmationController.identifier = "Offline"
        confirmationController.object = image
        confirmationController.affirmativeText = WRTools.getString(string: "okay")
        confirmationController.text = WRTools.getString(string: "image_rec_error")
        self.present(confirmationController, animated: true, completion: nil)
    }
    
    func finish() {
        displayWines.removeAll()
        showLoadingView()
        WRTools.startNewWorkThread {
            let context = NSManagedObjectContext.mr_()
            context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
            var wines = Array<Wine>()
            for image in self.images! {
                let info = self.imageInfo![image]!
                let wineId = self.imageMatches == nil ? nil : self.imageMatches![image]
                let offlineImage = image.jpegData(compressionQuality: 0.60)!
                
                var wineObject : Wine
                if (wineId != nil) {
                    wineObject = Wine.mr_findFirst(with: NSPredicate(format: "self IN %@", [wineId!]), in: context)!
                } else {
                    let wineDictionary = ["id" : WRTools.generateRandomLongId(), "created_at" : Date.init(), "updated_at" : Date.init(), "dirty" : true, "front_image" : offlineImage, "name" : info["name"] as? String ?? ""] as [String : Any]
                    let vintageDictionary = ["id" : WRTools.generateRandomLongId(), "year" : -1, "created_at" : Date.init(), "updated_at" : Date.init()] as [String : Any]
                    let vintageObject = Vintage.mr_import(from: vintageDictionary, in: context)
                    wineObject = Wine.mr_import(from: wineDictionary, in: context)
                    vintageObject.wine = wineObject
                }
                wines.append(wineObject)
                
                if (info["imageId"] != nil) {
                    let primaryImage = Media.mr_createEntity(in: context)
                    primaryImage?.closeLoop = true
                    primaryImage?.id = info["imageId"] as! NSNumber
                    wineObject.primary_image = primaryImage
                }
            }
            
            context.mr_saveToPersistentStoreAndWait()
            // make sure to grab this here, after we save!
            UserDefaults.init(suiteName: "WineRing")!.set(UserDefaults.init(suiteName: "WineRing")!.integer(forKey: "ratedWinesCount") + self.images!.count, forKey: "ratedWinesCount")
            UserDefaults.init(suiteName: "WineRing")!.set(nil, forKey: "lastCalledPreferences")
            UserDefaults.init(suiteName: "WineRing")!.set(nil, forKey: "lastUploadedDirty")
            SortType.getDefaultSortType(journalType: WineGroupType.RATING).saveSortTypeToUserDefaults(journalType: WineGroupType.RATING)
            SwiftEventBus.post("userUpdated")
            SwiftEventBus.post("journalRefreshed")
            
            let wineIds = wines.map { $0.objectID }
            
            DispatchQueue.main.async {
                self.hideLoadingView()
                self.clearData()
                self.doneButton.isHidden = true
                self.multiButton.isHidden = false
                self.displayWines.append(Wine.mr_findAll(with: NSPredicate(format: "self IN %@", wineIds)) as! [Wine])
                
                let winePagerController = UIStoryboard(name: "Wine", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "WinePager") as! WinePagerController
                let wineViewController = self.getViewControllerForIndexPath(indexPath: IndexPath.init(item: 0, section: 0))
                wineViewController?.winePagerProtocol = winePagerController
                winePagerController.setViewControllers([wineViewController!], direction: .forward, animated: true, completion: nil)
                winePagerController.currentIndexPath = IndexPath.init(item: 0, section: 0)
                winePagerController.winePagerDelegate = self
                self.navigationController?.pushViewController(winePagerController, animated: true)
            }
        }
    }
    
    func getTotalWineCount() -> Int {
        var totalCount = 0
        for section in displayWines {
            totalCount = totalCount + section.count
        }
        return totalCount
    }
    
    func getCurrentPosition(indexPath : IndexPath) -> Int {
        var totalCount = indexPath.row + 1
        let section = 0
        while section < indexPath.section {
            totalCount = totalCount + displayWines[section].count
        }
        return totalCount
    }
    
    public func getViewControllerForIndexPath(indexPath : IndexPath) -> WineDetailController? {
        if (displayWines.count <= indexPath.section || displayWines[indexPath.section].count <= indexPath.row) {
            return nil
        }
        let wineDetailViewController = UIStoryboard(name: "Wine", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "WineDetail") as! WineDetailController
        wineDetailViewController.wine = displayWines[indexPath.section][indexPath.row]
        wineDetailViewController.indexPath = indexPath
        wineDetailViewController.totalWines = getTotalWineCount()
        wineDetailViewController.currentWineLocation = getCurrentPosition(indexPath: indexPath)
        wineDetailViewController.moveAfterRate = true
        return wineDetailViewController
    }
    
    public func getViewControllerBeforeIndexPath(indexPath : IndexPath) -> WineDetailController? {
        if (indexPath.section <= 0 && indexPath.row <= 0) {
            // no previous wine
            return nil
        } else if (indexPath.row == 0) {
            let previousIndexPath = IndexPath.init(row: displayWines[indexPath.section - 1].count - 1, section: indexPath.section - 1)
            let previousViewController = getViewControllerForIndexPath(indexPath: previousIndexPath)
            return previousViewController
        } else {
            let previousIndexPath = IndexPath.init(row: indexPath.row - 1, section: indexPath.section)
            let previousViewController = getViewControllerForIndexPath(indexPath: previousIndexPath)
            return previousViewController
        }
    }
    
    public func getViewControllerAfterIndexPath(indexPath : IndexPath) -> WineDetailController? {
        if (indexPath.section >= displayWines.count || (indexPath.section == displayWines.count - 1 && indexPath.row == displayWines[indexPath.section].count - 1)) {
            // no next wine
            return nil
        } else if (indexPath.row >= displayWines[indexPath.section].count - 1) {
            let nextIndexPath = IndexPath.init(row: 0, section: indexPath.section + 1)
            let nextViewController = getViewControllerForIndexPath(indexPath: nextIndexPath)
            return nextViewController
        } else {
            let nextIndexPath = IndexPath.init(row: indexPath.row + 1, section: indexPath.section)
            let nextViewController = getViewControllerForIndexPath(indexPath: nextIndexPath)
            return nextViewController
        }
    }
    
    func clearData() {
        self.images?.removeAll()
        self.imageInfo?.removeAll()
        self.imageRecIds?.removeAll()
        self.imageMatches?.removeAll()
        self.imageMatchesWines?.removeAll()
    }
    
    func saveDiscardedSubmissionForLater(image : UIImage) {
        WRTools.startNewWorkThread {
            let context = NSManagedObjectContext.mr_()
            context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
            let offlineImage = image.jpegData(compressionQuality: 0.60)!
            let wineDictionary = ["id" : WRTools.generateRandomLongId(), "created_at" : Date.init(), "updated_at" : Date.init(), "dirty" : true, "front_image" : offlineImage] as [String : Any]
            let vintageDictionary = ["id" : WRTools.generateRandomLongId(), "year" : -1, "created_at" : Date.init(), "updated_at" : Date.init()] as [String : Any]
            let wine = Wine.mr_import(from: wineDictionary, in: context)
            let vintage = Vintage.mr_import(from: vintageDictionary, in: context)
            vintage.wine = wine
            wine.addToVintages(vintage)
            context.mr_saveToPersistentStoreAndWait()
            UserDefaults.init(suiteName: "WineRing")!.set(nil, forKey: "lastUploadedDirty")
        }
    }
    
    func uploadImageAfterTake(image : UIImage) {
        if (!multiMode) {
            self.imageRecIds = nil
        }
        
        WRTools.startNewWorkThread {
            do {
                self.dispatchGroup.wait()
                self.dispatchGroup.enter()
                defer { self.dispatchGroup.leave() }
                let context = NSManagedObjectContext.mr_()
                context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
                
                let imageId = try self.uploadImage(context: context, image: image)
                if (self.imageInfo == nil) {
                    self.imageInfo = [image : ["imageId" : imageId]]
                } else if (self.imageInfo![image] == nil) {
                    self.imageInfo![image] = ["imageId" : imageId]
                } else {
                    self.imageInfo![image]!["imageId"] = imageId
                }
                
                let imageRecIds = try self.getImageRecs(context: context, imageId: imageId)
                if (self.imageRecIds == nil) {
                    self.imageRecIds = [image : imageRecIds]
                } else {
                    self.imageRecIds![image] = imageRecIds
                }
            } catch {
                // nada
            }
        }
    }
    
    func uploadImage(context : NSManagedObjectContext, image : UIImage) throws -> NSNumber {
        let resizedImage = WRTools.resizeImage(image: image, newDimension: 1000)!
        let imageData = resizedImage.jpegData(compressionQuality: 0.60)!
        var mediaResponse = try WineRing.main.api.getAlamo().syncUpload(url: APIEndpoints.postMedia, data: imageData)
        mediaResponse = try WRTools.continueOrThrowWRException(response: mediaResponse, showError: false)
        let imageDictionary = try WRTools.continueOrThrowJSONException(data: mediaResponse.data!)
        let image = Media.mr_import(from: imageDictionary, in: context)
        context.mr_saveToPersistentStoreAndWait()
        return image.id
    }
    
    func getImageRecs(context : NSManagedObjectContext, imageId : NSNumber) throws -> Array<NSManagedObjectID> {
        var imageRecResponse = try WineRing.main.api.getAlamo().get(APIEndpoints.imageRec, params: ["media_id" : imageId])
        imageRecResponse = try WRTools.continueOrThrowWRException(response: imageRecResponse, showError: false)
        let imageRecDictionaries = try WRTools.continueOrThrowJSONException(data: imageRecResponse.data!) as! NSArray
        var imageRecs = Array<ImageRec>()
        for imageRec in imageRecDictionaries {
            imageRecs.append(ImageRec.mr_import(from: imageRec, in: context))
        }
        context.mr_saveToPersistentStoreAndWait()
        
        return imageRecs.map { $0.objectID }
    }
    
    func confirmationReceived(identifier: String, affirmative: Bool) {
        // nada
    }
    
    public override func goBack() {
        if (images != nil && multiMode) {
            let confirmationController = UIStoryboard(name: "Reusable", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "Confirmation") as! ConfirmationController
            confirmationController.modalPresentationStyle = .overCurrentContext
            confirmationController.delegate = self
            confirmationController.identifier = "Confirmation"
            confirmationController.affirmativeText = WRTools.getString(string: "okay")
            confirmationController.negativeText = WRTools.getString(string: "cancel")
            confirmationController.text = WRTools.getString(string: "batch_unsaved")
            present(confirmationController, animated: true, completion: nil)
        } else {
            super.goBack()
        }
    }
    
    public func confirmationReceived(identifier: String, affirmative: Bool, object: Any?) {
        if (identifier == "Offline") {
            resetView(turnTorchBackOn: false)
        } else if (identifier == "Allow") {
            if (affirmative) {
                WRTools.goToSettings()
            }
        } else if (identifier == "NoResults") {
            let image = object as! UIImage
            saveDiscardedSubmissionForLater(image: image)
            resetView(turnTorchBackOn: false)
        } else if (identifier == "Confirmation" && affirmative) {
            super.goBack()
        }
    }
    
    func resetView(turnTorchBackOn : Bool) {
        self.shouldSaveToCameraRoll = false
        if (self.previewLayer != nil && self.previewLayer!.connection != nil) {
            self.previewLayer!.connection!.isEnabled = true
        }
        if (CameraTools.sharedInstance.getCaptureDevice()?.isTorchAvailable ?? false && flashButton.isSelected) {
            flashButton.isSelected = turnTorchBackOn
            do {
                try CameraTools.sharedInstance.getCaptureDevice()?.lockForConfiguration()
                if (turnTorchBackOn) {
                    try CameraTools.sharedInstance.getCaptureDevice()?.setTorchModeOn(level: 1.0)
                } else {
                    CameraTools.sharedInstance.getCaptureDevice()?.torchMode = AVCaptureDevice.TorchMode.off
                }
            } catch {
                print(error)
            }
            CameraTools.sharedInstance.getCaptureDevice()?.unlockForConfiguration()
        }
    }
    
    func cancelPressed(identifier : Int) {
        resetView(turnTorchBackOn: true)
    }
    
    public func cancelPressed() {
        resetView(turnTorchBackOn: true)
    }
    
    func getViewControllerBefore(viewController: UIViewController) -> ImageRecMatchController? {
        let resultController = viewController as! ImageRecMatchController
        let previousImageIndex = (images!.firstIndex(of: resultController.actualImage!) ?? 0) - 1
        if (previousImageIndex < 0) {
            return nil
        }
        
        let image = images![previousImageIndex]
        
        if (self.imageInfo == nil) {
            self.imageInfo = [image : ["go" : "go"]]
        } else if (self.imageInfo![image] == nil) {
            self.imageInfo![image] = ["go" : "go"]
        }
        
        let viewController = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "ImageRecMatchController") as! ImageRecMatchController
        viewController.actualImage = image
        viewController.info = imageInfo![image]
        viewController.recResults = imageRecIds?[image]
        viewController.multi = multiMode
        viewController.match = imageMatchesWines?[image]
        viewController.currentWineLocation = images!.firstIndex(of: image)! + 1
        viewController.totalWines = images!.count
        return viewController
    }
    
    func getViewControllerAfter(viewController: UIViewController) -> ImageRecMatchController? {
        let resultController = viewController as! ImageRecMatchController
        let nextImageIndex = (images!.firstIndex(of: resultController.actualImage!) ?? 500) + 1
        if (images!.count <= nextImageIndex) {
            return nil
        }
        
        let image = images![nextImageIndex]
        
        if (self.imageInfo == nil) {
            self.imageInfo = [image : ["go" : "go"]]
        } else if (self.imageInfo![image] == nil) {
            self.imageInfo![image] = ["go" : "go"]
        }
        
        let viewController = UIStoryboard(name: "SearchWines", bundle: Bundle.init(for: WineRing.self)).instantiateViewController(withIdentifier: "ImageRecMatchController") as! ImageRecMatchController
        viewController.actualImage = image
        viewController.info = imageInfo![image]
        viewController.match = imageMatchesWines?[image]
        viewController.recResults = imageRecIds?[image]
        viewController.multi = multiMode
        viewController.currentWineLocation = images!.firstIndex(of: image)! + 1
        viewController.totalWines = images!.count
        return viewController
    }
    
    func matchSelected(image: UIImage, wine: Wine?) {
        if (imageMatches == nil && wine != nil) {
            imageMatches = [image : wine!.objectID]
            imageMatchesWines = [image : wine!]
        } else if (imageMatches != nil && wine == nil) {
            imageMatches!.removeValue(forKey: image)
            imageMatchesWines!.removeValue(forKey: image)
        } else if (wine != nil) {
            imageMatches![image] = wine!.objectID
            imageMatchesWines![image] = wine!
        }
    }
}

